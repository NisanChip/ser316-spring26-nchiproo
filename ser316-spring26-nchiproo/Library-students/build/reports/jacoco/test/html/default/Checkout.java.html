<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Checkout.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Library-students</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">Checkout.java</span></div><h1>Checkout.java</h1><pre class="source lang-java linenums">import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Manages library checkout operations.
 * Handles book checkouts, returns, renewals, and fine calculations.
 */
public class Checkout {
<span class="fc" id="L13">    public static double MAX_FINE_AMOUNT = 25.0;</span>

    private Map&lt;String, Book&gt; bookList; // ISBN -&gt; Book
    private Map&lt;String, Patron&gt; patrons; // PatronID -&gt; Patron
    private List&lt;Transaction&gt; history; //

    /**
     * Inner class to track checkout transactions.
     */
    private static class Transaction {
        Patron patron;
        Book book;
        LocalDate checkoutDate;
        LocalDate dueDate;
        LocalDate returnDate;

<span class="nc" id="L29">        Transaction(Patron patron, Book book, LocalDate checkoutDate, LocalDate dueDate) {</span>
<span class="nc" id="L30">            this.patron = patron;</span>
<span class="nc" id="L31">            this.book = book;</span>
<span class="nc" id="L32">            this.checkoutDate = checkoutDate;</span>
<span class="nc" id="L33">            this.dueDate = dueDate;</span>
<span class="nc" id="L34">            this.returnDate = null;</span>
<span class="nc" id="L35">        }</span>
    }

<span class="fc" id="L38">    public Checkout() {</span>
<span class="fc" id="L39">        this.bookList = new HashMap&lt;&gt;();</span>
<span class="fc" id="L40">        this.patrons = new HashMap&lt;&gt;();</span>
<span class="fc" id="L41">        this.history = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L42">    }</span>

    public void addBook(Book book) {
<span class="fc" id="L45">        bookList.put(book.getIsbn(), book);</span>
<span class="fc" id="L46">    }</span>

    public void registerPatron(Patron patron) {
<span class="fc" id="L49">        patrons.put(patron.getPatronId(), patron);</span>
<span class="fc" id="L50">    }</span>

    /**
     * Validates if a patron is eligible to check out books you can assume this method is correct.
     * This helper method consolidates patron-related eligibility checks.
     * Students can assume this method is correct and use it in their implementation.
     *
     * Returns error codes for the following conditions (checked in order):
     * - Patron is null → 3.1
     * - Account is suspended → 3.0
     * - Has 3 or more overdue books → 4.0
     * - Has $10.00 or more in fines → 4.1
     *
     * @param patron The patron to validate
     * @return 0.0 if eligible, or appropriate error code (3.1, 3.0, 4.0, 4.1)
     */
    public double validatePatronEligibility(Patron patron) {
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (patron == null) {</span>
<span class="nc" id="L68">            return 3.1;</span>
        }
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (patron.isAccountSuspended()) {</span>
<span class="nc" id="L71">            return 3.0;</span>
        }
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if (patron.getOverdueCount() &gt;= 3) {</span>
<span class="nc" id="L74">            return 4.0;</span>
        }
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">        if (patron.getFineBalance() &gt;= 10.0) {</span>
<span class="nc" id="L77">            return 4.1;</span>
        }
<span class="fc" id="L79">        return 0.0; // Eligible</span>
    }

    /**
     * Main checkout method - processes a book checkout for a patron.
     * This method performs comprehensive validation and returns a status code.
     *
     * TESTING NOTE: Transaction history is maintained internally and can be assumed
     * to work correctly. Students performing black-box testing should focus on:
     * - Return codes (observable via the method return value)
     * - Book availability changes (observable via book.getAvailableCopies())
     * - Patron's checked-out books (observable via patron.getCheckedOutBooks())
     * Do NOT attempt to test transaction history - it is not publicly accessible.
     *
     * Return codes:
     *   0.0 - Success, book checked out normally
     *   0.1 - Success, renewal (patron already had this book, renewal sets the due date to (today + patron.getLoanPeriodDays()).)
     *   1.0 - Success with warning (patron has 1-2 overdue books)
     *   1.1 - Success with warning (patron within 2 of max checkout limit after this checkout)
     *        Max limits: FACULTY=20 (e.g. warning at 18, 19, 20 including current checkout), STAFF=15, STUDENT=10, PUBLIC=5, CHILD=3
     *   2.0 - Book unavailable (all copies checked out)
     *   2.1 - Book is null
     *   3.0 - Patron account is suspended
     *   3.1 - Patron is null
     *   3.2 - Patron at maximum checkout limit (FACULTY=20, STAFF=15, STUDENT=10, PUBLIC=5, CHILD=3)
     *   4.0 - Patron has 3 or more overdue books
     *   4.1 - Patron has $10.00 or more in unpaid fines
     *   5.0 - Book is reference-only (cannot be checked out)
     *
     * Validation order (observable priority when multiple conditions apply):
     *   1. Call validatePatronEligibility() assume this method is correct - returns in this order
     *      1.1. eligible 0.0 -&gt; continue with step 2
     *      1.2. checks patron null (3.1) -&gt; return this error code right away
     *      1.3. suspended (3.0) -&gt; return this error code right away
     *      1.4. overdue count &gt;= 3 (4.0) -&gt; return this error code right away
     *      1.5. fines &gt;= $10 (4.1) -&gt; return this error code right away
     *   2. Check if book is null (2.1)
     *   3. Check if book is reference-only (5.0)
     *   4. If renewal, return 0.1 immediately (renew skips step 5)
     *   5. If not-renewal
     *      5.1. Check if book is available (2.0)
     *      5.2. Check if patron is at max checkout limit (3.2)
     *      5.3. Process checkout (update patron checkedOutBooks, call book.checkout()), then determine success code (priority 1.0, then 1.1, else 0.0)
     *
     *
     * Success non-renewal:
     *   - book will be added to list of checkedOutBooks of patron with dueDate = today + patron.getLoanPeriodDays()
     *   - book.checkout() will be called reducing the availability by 1
     *
     * Success renewal:
     *  - patron.getCheckedOutBooks() is updated to today + loanPeriodDays; book.checkout() is not called; available copies do not change.
     *
     * Additional notes:
     *  - getCheckoutCount() refers to the number of books currently checked out (size of the patron's checked-out collection), not lifetime transactions; renewals do not increase this count.
     *  - For any non-success return code (2.x–5.x), neither the patron's checked-out books nor the book's available copies should change.
     *  - Tests may assume due dates equal LocalDate.now().plusDays(patron.getLoanPeriodDays()) on the day the test runs.
     *  - A book is unavailable if and only if book.getAvailableCopies() &lt;= 0 (i.e., book.isAvailable() is false).
     *  - Console output (including Easter eggs) is non-functional and should not be asserted in tests.
     *
     * @param book The book to checkout (can be null)
     * @param patron The patron checking out the book (can be null)
     * @return Status code indicating result (see above)
     */
    public double checkoutBook(Book book, Patron patron) {
//        Implement me in Assignment 3
        // Normal success
<span class="nc" id="L145">        return 0.0;</span>
    }


    /**
     * Calculates the fine amount for an overdue book. Assume this javadoc is correct.
     *
     * Fine calculation rules:
     * - First 7 days overdue: $0.25 per day
     * - Days 8-14 overdue: $0.50 per day
     * - Days 15+ overdue: $1.00 per day
     * - REFERENCE and TEXTBOOK types: double the normal rate
     * - Maximum fine per book: $25.00
     *
     * Examples:
     * - 5 days overdue, FICTION: 5 * $0.25 = $1.25
     * - 10 days overdue, NONFICTION: (7 * $0.25) + (3 * $0.50) = $3.25
     * - 20 days overdue, TEXTBOOK: ((7*$0.25) + (7*$0.50) + (6*$1.00)) * 2 = $23.50
     * - 50 days overdue, FICTION: would be $41.75, but capped at $25.00
     *
     * @param numOfDays Number of days the book is overdue
     * @param bookType The type of book (affects fine rate)
     * @return Fine amount in dollars
     */
    public double calculateFine(int numOfDays, Book.BookType bookType) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (numOfDays &lt;= 0) {</span>
<span class="nc" id="L171">            return 0.0;</span>
        }

<span class="nc" id="L174">        double fine = 0.0;</span>

        // First 7 days: $0.25/day
<span class="nc" id="L177">        int days1 = Math.min(numOfDays, 7);</span>
<span class="nc" id="L178">        fine += days1 * 0.25;</span>

        // Days 8-14: $0.50/day
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (numOfDays &gt; 7) {</span>
<span class="nc" id="L182">            int days2 = Math.min(numOfDays - 7, 7);</span>
<span class="nc" id="L183">            fine += days2 * 0.50;</span>
        }

        // Days 15+: $1.00/day
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (numOfDays &gt; 14) {</span>
<span class="nc" id="L188">            int days3 = numOfDays - 14;</span>
<span class="nc" id="L189">            fine += days3 * 1.00;</span>
        }

        // Double rate for REFERENCE and TEXTBOOK
<span class="nc bnc" id="L193" title="All 4 branches missed.">        if (bookType == Book.BookType.REFERENCE || bookType == Book.BookType.TEXTBOOK) {</span>
<span class="nc" id="L194">            fine *= 2.0;</span>
        }

        // Cap at maximum fine amount
<span class="nc" id="L198">        return Math.min(fine, MAX_FINE_AMOUNT);</span>
    }

    /**
     * Validates ISBN format you can assume this javadoc is correct.
     * Valid formats:
     * - ISBN-10: 10 digits (e.g., &quot;0123456789&quot;)
     * - ISBN-13: 13 digits (e.g., &quot;9780123456789&quot;)
     * - ISBN with hyphens: XXX-X-XXXX-XXXX-X (e.g., &quot;978-0-1234-5678-9&quot;)
     *
     * Invalid:
     * - null or empty strings
     * - Contains letters or special characters (except hyphens)
     * - Wrong number of digits after removing hyphens
     *
     * @param isbn The ISBN string to validate
     * @return true if valid format, false otherwise
     */
    public boolean isValidISBN(String isbn) {
<span class="nc bnc" id="L217" title="All 4 branches missed.">        if (isbn == null || isbn.isEmpty()) {</span>
<span class="nc" id="L218">            return false;</span>
        }


<span class="nc" id="L222">        String numbers = isbn.replace(&quot;-&quot;, &quot;&quot;);</span>

        // Check if all remaining characters are digits
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (!numbers.matches(&quot;\\d+&quot;)) {</span>
<span class="nc" id="L226">            return false;</span>
        }

        // Check length (must be 10 or 13 digits)
<span class="nc" id="L230">        int length = numbers.length();</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">        return length == 10 || length == 13;</span>
    }

    /**
     * Checks if a patron type string matches a given type.
     *
     * @param typeString The type as a string
     * @param expectedType The expected patron type
     * @return true if types match
     */
    public boolean isPatronType(String typeString, Patron.PatronType expectedType) {
<span class="nc bnc" id="L242" title="All 4 branches missed.">        if (typeString == null || expectedType == null) {</span>
<span class="nc" id="L243">            return false;</span>
        }

<span class="nc bnc" id="L246" title="All 2 branches missed.">        return typeString == expectedType.toString();</span>
    }

    /**
     * Processes a book return.
     * Calculates any overdue fines and updates patron/book status.
     *
     * @param isbn The ISBN of the book being returned
     * @param patron The patron returning the book
     * @return Fine amount charged (0.0 if not overdue)
     */
    public double returnBook(String isbn, Patron patron) {
<span class="nc bnc" id="L258" title="All 4 branches missed.">        if (patron == null || !patron.hasBookCheckedOut(isbn)) {</span>
<span class="nc" id="L259">            return -1.0;</span>
        }

<span class="nc" id="L262">        Book book = bookList.get(isbn);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (book == null) {</span>
<span class="nc" id="L264">            return -1.0;</span>
        }

<span class="nc" id="L267">        LocalDate dueDate = patron.getCheckedOutBooks().get(isbn);</span>
<span class="nc" id="L268">        LocalDate today = LocalDate.now();</span>
<span class="nc" id="L269">        long daysOverdue = ChronoUnit.DAYS.between(dueDate, today);</span>

<span class="nc" id="L271">        double fine = 0.0;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (daysOverdue &gt; 0) {</span>
<span class="nc" id="L273">            fine = calculateFine((int) daysOverdue, book.getType());</span>
<span class="nc" id="L274">            patron.addFine(fine);</span>
        }

        // Update patron and book
<span class="nc" id="L278">        patron.removeCheckedOutBook(isbn);</span>
<span class="nc" id="L279">        book.returnBook();</span>

        // Update transaction history to mark book as returned
<span class="nc bnc" id="L282" title="All 2 branches missed.">        for (Transaction t : history) {</span>
<span class="nc bnc" id="L283" title="All 6 branches missed.">            if (t.patron.equals(patron) &amp;&amp; t.book.equals(book) &amp;&amp; t.returnDate == null) {</span>
<span class="nc" id="L284">                t.returnDate = today;</span>
<span class="nc" id="L285">                break;</span>
            }
<span class="nc" id="L287">        }</span>

<span class="nc" id="L289">        return fine;</span>
    }

    /**
     * Counts available books of a specific type in inventory.
     * Useful for inventory management and reporting.
     *
     * This method demonstrates more complex control flow for white-box testing:
     * - Loop iteration
     * - Nested conditional statements
     * - Multiple decision points
     *
     * @param type The book type to count (FICTION, NONFICTION, REFERENCE, TEXTBOOK, CHILDREN)
     * @param onlyAvailable If true, counts only books with availableCopies &gt; 0;
     *                      if false, counts all books of the type regardless of availability
     * @return Number of books matching the criteria (0 if type is null or no matches found)
     */
    public int countBooksByType(Book.BookType type, boolean onlyAvailable) {

<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L309">            return 0;</span>
        }

<span class="nc" id="L312">        int looped = 0;</span>

        // Loop through all books in inventory
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (Book b : bookList.values()) {</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (b == null) {</span>
<span class="nc" id="L318">                continue;</span>
            }

            // Check if book matches the requested type
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (b.getType() == type) {</span>
                // Nested condition: filter by availability if requested
<span class="nc bnc" id="L324" title="All 2 branches missed.">                if (onlyAvailable) {</span>
                    // Only count if book has available copies
<span class="nc bnc" id="L326" title="All 2 branches missed.">                    if (b.isAvailable()) {</span>
<span class="nc" id="L327">                        looped++;</span>
                    }
                } else {
                    // Count all books of this type regardless of availability
<span class="nc" id="L331">                    looped++;</span>
                }
            }
<span class="nc" id="L334">        }</span>

<span class="nc" id="L336">        return looped;</span>
    }

    public Map&lt;String, Book&gt; getInventory() {
<span class="nc" id="L340">        return bookList;</span>
    }

    public Map&lt;String, Patron&gt; getPatrons() {
<span class="nc" id="L344">        return patrons;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>